import connectMongo from "@/libs/mongoose";
import FormSubmission from "@/models/FormSubmission";
import Form from "@/models/Form";
import FormSubmissionFile from "@/models/FormSubmissionFile";
import Vehicle from "@/models/Vehicle";
import VehicleTask from "@/models/VehicleTask";
import { requireDealerContext } from "@/libs/authContext";

export default async function handler(req, res) {
  await connectMongo();

  // GET requires authentication
  if (req.method === "GET") {
    try {
      const ctx = await requireDealerContext(req, res);
      const { dealerId } = ctx;
      let { formId, formType, search, startDate, endDate } = req.query;

      let query = { dealerId };

      // Filter by form
      if (formId) {
        query.formId = formId;
      }

      // Filter by form type
      if (formType) {
        const forms = await Form.find({ dealerId, type: formType });
        const formIds = forms.map((f) => f._id);
        query.formId = { $in: formIds };
      }

      // Date range filter
      if (startDate || endDate) {
        query.submittedAt = {};
        if (startDate) query.submittedAt.$gte = new Date(startDate);
        if (endDate) query.submittedAt.$lte = new Date(endDate);
      }

      // Search filter (search in rawAnswers)
      if (search) {
        query.$or = [
          { "rawAnswers.name": { $regex: search, $options: "i" } },
          { "rawAnswers.email": { $regex: search, $options: "i" } },
          { "rawAnswers.phone": { $regex: search, $options: "i" } },
          { "rawAnswers.reg": { $regex: search, $options: "i" } },
          { "rawAnswers.vrm": { $regex: search, $options: "i" } },
        ];
      }

      const submissions = await FormSubmission.find(query)
        .populate("formId")
        .populate("submittedByContactId")
        .populate("linkedVehicleId")
        .populate("linkedAftercareCaseId")
        .sort({ submittedAt: -1 });

      return res.status(200).json(submissions);
    } catch (error) {
      return res.status(error.status || 500).json({ error: error.message || "Failed to fetch submissions" });
    }
  }

  // POST is public - form submissions from public forms
  if (req.method === "POST") {
    try {
      const { formId, rawAnswers, submittedByContactId, files } = req.body;

      if (!formId || !rawAnswers) {
        return res.status(400).json({ error: "Missing required fields" });
      }

      const form = await Form.findById(formId);
      if (!form) {
        return res.status(404).json({ error: "Form not found" });
      }

      // Ensure dealerId is set - fallback to first dealer if form doesn't have one
      let dealerId = form.dealerId;
      if (!dealerId) {
        const Dealer = (await import("@/models/Dealer")).default;
        const firstDealer = await Dealer.findOne().lean();
        if (firstDealer) {
          dealerId = firstDealer._id;
          // Also update the form to have the dealerId for future submissions
          await Form.findByIdAndUpdate(formId, { dealerId });
        }
      }

      const submission = await FormSubmission.create({
        formId,
        dealerId,
        rawAnswers,
        submittedByContactId,
        submittedAt: new Date(),
      });

      // Handle file uploads if provided
      if (files && Array.isArray(files)) {
        const filePromises = files.map((file) =>
          FormSubmissionFile.create({
            formSubmissionId: submission._id,
            ...file,
          })
        );
        await Promise.all(filePromises);
      }

      // Vehicle integration - update vehicle records based on form type
      const vrm = rawAnswers.vrm || rawAnswers.courtesy_vrm || rawAnswers.vehicle_reg;
      if (vrm) {
        const vehicle = await Vehicle.findOne({
          regCurrent: vrm.toUpperCase().replace(/\s/g, ""),
          dealerId: form.dealerId
        });

        if (vehicle) {
          const updates = {};

          switch (form.type) {
            case "PDI":
              updates.pdiSubmissionId = submission._id;
              updates.pdiCompletedAt = new Date();
              // Auto-complete PDI task on this vehicle (idempotent - only if not already done)
              try {
                const pdiTask = await VehicleTask.findOne({
                  vehicleId: vehicle._id,
                  name: { $regex: /^(PDI|Pre-Delivery Inspection|Pre Delivery Inspection)$/i }
                });
                if (pdiTask && pdiTask.status !== "done" && pdiTask.status !== "DONE") {
                  await VehicleTask.findByIdAndUpdate(pdiTask._id, {
                    status: "done",
                    completedAt: new Date(),
                    notes: pdiTask.notes ? `${pdiTask.notes}\n\nCompleted via form submission` : "Completed via form submission"
                  });
                }
              } catch (taskError) {
                console.error("Error completing PDI task:", taskError);
                // Don't fail the submission if task completion fails
              }
              break;

            case "TEST_DRIVE":
              updates.testDriveCount = (vehicle.testDriveCount || 0) + 1;
              break;

            case "DELIVERY":
              updates.deliverySubmissionId = submission._id;
              updates.status = "delivered";
              // Auto-complete Delivery task on this vehicle (idempotent)
              try {
                const deliveryTask = await VehicleTask.findOne({
                  vehicleId: vehicle._id,
                  name: { $regex: /^(Delivery|Vehicle Delivery|Handover)$/i }
                });
                if (deliveryTask && deliveryTask.status !== "done" && deliveryTask.status !== "DONE") {
                  await VehicleTask.findByIdAndUpdate(deliveryTask._id, {
                    status: "done",
                    completedAt: new Date(),
                    notes: deliveryTask.notes ? `${deliveryTask.notes}\n\nCompleted via form submission` : "Completed via form submission"
                  });
                }
              } catch (taskError) {
                console.error("Error completing Delivery task:", taskError);
              }
              break;
          }

          if (Object.keys(updates).length > 0) {
            await Vehicle.findByIdAndUpdate(vehicle._id, { $set: updates });
          }
        }
      }

      return res.status(201).json(submission);
    } catch (error) {
      console.error("Error creating submission:", error);
      return res.status(500).json({ error: "Failed to create submission" });
    }
  }

  return res.status(405).json({ error: "Method not allowed" });
}
