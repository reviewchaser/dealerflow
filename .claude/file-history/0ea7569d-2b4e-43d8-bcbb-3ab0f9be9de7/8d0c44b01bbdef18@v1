import connectMongo from "@/libs/mongoose";
import Deal from "@/models/Deal";
import Vehicle from "@/models/Vehicle";
import Dealer from "@/models/Dealer";
import SalesDocument from "@/models/SalesDocument";
import crypto from "crypto";
import { withDealerContext } from "@/libs/authContext";

/**
 * Generate Invoice API
 * POST /api/deals/[id]/generate-invoice
 *
 * Generates an invoice for a deal and transitions status to INVOICED.
 */
async function handler(req, res, ctx) {
  await connectMongo();
  const { dealerId, userId } = ctx;
  const { id } = req.query;

  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  // Validate ID format
  if (!id || !id.match(/^[0-9a-fA-F]{24}$/)) {
    return res.status(400).json({ error: "Invalid deal ID" });
  }

  // Get the deal with all related data
  const deal = await Deal.findOne({ _id: id, dealerId })
    .populate("vehicleId")
    .populate("soldToContactId")
    .populate("invoiceToContactId")
    .populate("partExchangeId");

  if (!deal) {
    return res.status(404).json({ error: "Deal not found" });
  }

  // Validate deal can be invoiced
  if (deal.status === "CANCELLED") {
    return res.status(400).json({ error: "Cannot invoice a cancelled deal" });
  }
  if (deal.status === "COMPLETED") {
    return res.status(400).json({ error: "Deal is already completed" });
  }
  if (deal.status === "INVOICED" || deal.status === "DELIVERED") {
    // Check if invoice already exists
    const existingInvoice = await SalesDocument.findOne({
      dealId: deal._id,
      type: "INVOICE",
      status: { $ne: "VOID" },
    });
    if (existingInvoice) {
      return res.status(400).json({
        error: "Invoice already exists",
        invoiceId: existingInvoice._id.toString(),
        documentNumber: existingInvoice.documentNumber,
      });
    }
  }

  // Customer is required
  if (!deal.soldToContactId) {
    return res.status(400).json({ error: "Customer is required before generating invoice" });
  }

  // Vehicle price is required
  if (!deal.vehiclePriceGross && deal.vehiclePriceGross !== 0) {
    return res.status(400).json({ error: "Vehicle price is required before generating invoice" });
  }

  // Get dealer for settings and document numbering
  const dealer = await Dealer.findByIdAndUpdate(
    dealerId,
    { $inc: { "salesSettings.nextInvoiceNumber": 1 } },
    { new: false }
  );

  const prefix = dealer?.salesSettings?.invoiceNumberPrefix || "INV";
  const invoiceNumber = dealer?.salesSettings?.nextInvoiceNumber || 1;
  const documentNumber = `${prefix}${String(invoiceNumber).padStart(5, "0")}`;

  // Calculate totals
  const vehicle = deal.vehicleId;
  const customer = deal.soldToContactId;
  const invoiceTo = deal.invoiceToContactId;
  const px = deal.partExchangeId;

  // Add-ons calculations
  const addOnsNetTotal = (deal.addOns || []).reduce((sum, a) => sum + (a.unitPriceNet * (a.qty || 1)), 0);
  const addOnsVatTotal = (deal.addOns || []).reduce((sum, a) => {
    if (a.vatTreatment === "STANDARD") {
      return sum + (a.unitPriceNet * (a.qty || 1) * (a.vatRate || 0.2));
    }
    return sum;
  }, 0);

  // Total payments
  const totalPaid = (deal.payments || [])
    .filter(p => !p.isRefunded)
    .reduce((sum, p) => sum + p.amount, 0);

  // Part exchange net value
  const pxNetValue = px ? (px.allowance || 0) - (px.settlement || 0) : 0;

  // Calculate grand total based on VAT scheme
  let subtotal, totalVat, grandTotal;

  if (deal.vatScheme === "VAT_QUALIFYING") {
    subtotal = (deal.vehiclePriceNet || 0) + addOnsNetTotal;
    totalVat = (deal.vehicleVatAmount || 0) + addOnsVatTotal;
    grandTotal = subtotal + totalVat;
  } else {
    // Margin scheme - no VAT breakdown
    subtotal = (deal.vehiclePriceGross || 0) + addOnsNetTotal + addOnsVatTotal;
    totalVat = 0;
    grandTotal = subtotal;
  }

  const balanceDue = grandTotal - totalPaid - pxNetValue;

  // Build snapshot data
  const snapshotData = {
    vehicle: {
      regCurrent: vehicle.regCurrent,
      vin: vehicle.vin,
      make: vehicle.make,
      model: vehicle.model,
      derivative: vehicle.derivative,
      year: vehicle.year,
      mileage: vehicle.mileageCurrent,
      colour: vehicle.colour,
    },
    customer: {
      name: customer.displayName,
      companyName: customer.companyName,
      email: customer.email,
      phone: customer.phone,
      address: customer.address,
    },
    invoiceTo: invoiceTo ? {
      name: invoiceTo.displayName,
      companyName: invoiceTo.companyName,
      email: invoiceTo.email,
      address: invoiceTo.address,
    } : null,
    vatScheme: deal.vatScheme,
    vehiclePriceNet: deal.vehiclePriceNet,
    vehicleVatAmount: deal.vehicleVatAmount,
    vehiclePriceGross: deal.vehiclePriceGross,
    addOns: (deal.addOns || []).map(a => ({
      name: a.name,
      qty: a.qty || 1,
      unitPriceNet: a.unitPriceNet,
      vatTreatment: a.vatTreatment,
      vatRate: a.vatRate,
    })),
    addOnsNetTotal,
    addOnsVatTotal,
    partExchange: px ? {
      vrm: px.vrm,
      make: px.make,
      model: px.model,
      allowance: px.allowance,
      settlement: px.settlement,
    } : null,
    payments: (deal.payments || []).map(p => ({
      type: p.type,
      amount: p.amount,
      method: p.method,
      paidAt: p.paidAt,
      reference: p.reference,
    })),
    subtotal,
    totalVat,
    grandTotal,
    totalPaid,
    partExchangeNet: pxNetValue,
    balanceDue,
    termsText: deal.termsSnapshotText || getTermsText(deal, dealer),
    dealer: {
      name: dealer.name,
      companyName: dealer.companyName,
      address: dealer.companyAddress,
      phone: dealer.companyPhone,
      email: dealer.companyEmail,
      vatNumber: dealer.salesSettings?.vatNumber,
      companyNumber: dealer.salesSettings?.companyNumber,
    },
    bankDetails: dealer.salesSettings?.bankDetails || {},
  };

  // Generate share token
  const shareToken = crypto.randomBytes(32).toString("base64url");
  const shareTokenHash = crypto.createHash("sha256").update(shareToken).digest("hex");

  // Create invoice document
  const invoice = await SalesDocument.create({
    dealerId,
    dealId: deal._id,
    type: "INVOICE",
    documentNumber,
    status: "ISSUED",
    issuedAt: new Date(),
    snapshotData,
    shareToken,
    shareTokenHash,
    shareExpiresAt: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 days
    createdByUserId: userId,
  });

  // Update deal
  deal.status = "INVOICED";
  deal.invoicedAt = new Date();
  deal.updatedByUserId = userId;
  await deal.save();

  // Update vehicle status
  await Vehicle.findByIdAndUpdate(deal.vehicleId._id, {
    salesStatus: "SOLD_IN_PROGRESS",
  });

  return res.status(200).json({
    success: true,
    dealId: deal._id.toString(),
    dealStatus: deal.status,
    invoiceId: invoice._id.toString(),
    documentNumber,
    shareToken,
    shareUrl: `${process.env.NEXTAUTH_URL || ""}/public/invoice/${shareToken}`,
    grandTotal,
    balanceDue,
  });
}

/**
 * Get appropriate terms text based on buyer type and sale channel
 */
function getTermsText(deal, dealer) {
  const terms = dealer?.salesSettings?.terms || {};
  const key = `${deal.buyerType?.toLowerCase() || "consumer"}${deal.saleChannel === "DISTANCE" ? "Distance" : "InPerson"}`;
  return terms[key] || terms.consumerInPerson || "";
}

export default withDealerContext(handler);
