import connectMongo from "@/libs/mongoose";
import Deal from "@/models/Deal";
import Vehicle from "@/models/Vehicle";
import { withDealerContext } from "@/libs/authContext";

/**
 * Mark Completed API
 * POST /api/deals/[id]/mark-completed
 *
 * Marks deal as fully completed (all payments received, delivered, admin done).
 * This is the final status in the deal lifecycle.
 */
async function handler(req, res, ctx) {
  await connectMongo();
  const { dealerId, userId } = ctx;
  const { id } = req.query;

  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  // Validate ID format
  if (!id || !id.match(/^[0-9a-fA-F]{24}$/)) {
    return res.status(400).json({ error: "Invalid deal ID" });
  }

  const {
    completionNotes,
    sendReviewRequest, // Whether to trigger review request email
  } = req.body;

  // Get the deal with related data
  const deal = await Deal.findOne({ _id: id, dealerId })
    .populate("vehicleId")
    .populate("soldToContactId");

  if (!deal) {
    return res.status(404).json({ error: "Deal not found" });
  }

  // Validate deal can be completed
  if (deal.status === "CANCELLED") {
    return res.status(400).json({ error: "Cannot complete a cancelled deal" });
  }
  if (deal.status === "COMPLETED") {
    return res.status(400).json({ error: "Deal is already completed" });
  }
  if (deal.status === "DRAFT") {
    return res.status(400).json({
      error: "Deal must progress through deposit/invoice/delivery before completion"
    });
  }

  // Calculate totals to check if fully paid
  const addOnsNetTotal = (deal.addOns || []).reduce((sum, a) => sum + (a.unitPriceNet * (a.qty || 1)), 0);
  const addOnsVatTotal = (deal.addOns || []).reduce((sum, a) => {
    if (a.vatTreatment === "STANDARD") {
      return sum + (a.unitPriceNet * (a.qty || 1) * (a.vatRate || 0.2));
    }
    return sum;
  }, 0);

  let grandTotal;
  if (deal.vatScheme === "VAT_QUALIFYING") {
    const subtotal = (deal.vehiclePriceNet || 0) + addOnsNetTotal;
    const totalVat = (deal.vehicleVatAmount || 0) + addOnsVatTotal;
    grandTotal = subtotal + totalVat;
  } else {
    grandTotal = (deal.vehiclePriceGross || 0) + addOnsNetTotal + addOnsVatTotal;
  }

  const totalPaid = (deal.payments || [])
    .filter(p => !p.isRefunded)
    .reduce((sum, p) => sum + p.amount, 0);

  // Part exchange value
  const pxNetValue = deal.partExchangeId
    ? (deal.partExchangeAllowance || 0) - (deal.partExchangeSettlement || 0)
    : 0;

  const balanceDue = grandTotal - totalPaid - pxNetValue;

  // Warn if not fully paid (but still allow completion)
  const isFullyPaid = balanceDue <= 0.01; // Allow for rounding

  // Update deal
  deal.status = "COMPLETED";
  deal.completedAt = new Date();
  deal.completionNotes = completionNotes || deal.completionNotes;
  deal.updatedByUserId = userId;
  await deal.save();

  // Update vehicle status
  await Vehicle.findByIdAndUpdate(deal.vehicleId._id, {
    salesStatus: "COMPLETED",
    status: "SOLD", // Update main vehicle status too
  });

  // TODO: If sendReviewRequest is true and customer has email, queue review request email
  // This would integrate with an email service like SendGrid or Resend

  return res.status(200).json({
    success: true,
    dealId: deal._id.toString(),
    dealStatus: deal.status,
    completedAt: deal.completedAt,
    isFullyPaid,
    balanceDue: isFullyPaid ? 0 : balanceDue,
    message: isFullyPaid
      ? "Deal completed successfully"
      : `Deal completed with outstanding balance of Â£${balanceDue.toFixed(2)}`,
  });
}

export default withDealerContext(handler);
