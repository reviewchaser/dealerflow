import connectMongo from "@/libs/mongoose";
import { withSuperAdmin } from "@/libs/authContext";
import Dealer, { DEALER_STATUS, DEALER_PLAN, APPROVAL_STATUS } from "@/models/Dealer";
import DealerMembership from "@/models/DealerMembership";
import Vehicle from "@/models/Vehicle";
import User from "@/models/User";
import PlatformActivity, { ACTIVITY_TYPES } from "@/models/PlatformActivity";

async function handler(req, res, ctx) {
  await connectMongo();

  // GET - List all dealers with stats
  if (req.method === "GET") {
    try {
      const dealers = await Dealer.find()
        .sort({ createdAt: -1 })
        .lean();

      // Enrich with counts and owner info
      const enrichedDealers = await Promise.all(
        dealers.map(async (dealer) => {
          const [usersCount, vehiclesCount, ownerMembership] = await Promise.all([
            DealerMembership.countDocuments({ dealerId: dealer._id, removedAt: null }),
            Vehicle.countDocuments({ dealerId: dealer._id }),
            DealerMembership.findOne({ dealerId: dealer._id, role: "OWNER", removedAt: null })
              .populate("userId", "email fullName name")
              .lean(),
          ]);

          // Get last activity for this dealer
          const lastActivity = await DealerMembership.findOne({ dealerId: dealer._id })
            .sort({ lastActiveAt: -1 })
            .select("lastActiveAt")
            .lean();

          return {
            id: dealer._id.toString(),
            name: dealer.name,
            status: dealer.status || DEALER_STATUS.ACTIVE,
            plan: dealer.plan || DEALER_PLAN.TRIAL,
            approvalStatus: dealer.approvalStatus || APPROVAL_STATUS.APPROVED,
            approvedAt: dealer.approvedAt,
            rejectedAt: dealer.rejectedAt,
            rejectionReason: dealer.rejectionReason,
            createdAt: dealer.createdAt,
            completedOnboarding: dealer.completedOnboarding || false,
            enabledModules: dealer.onboarding?.enabledModules || {},
            usersCount,
            vehiclesCount,
            ownerEmail: ownerMembership?.userId?.email || "—",
            ownerName: ownerMembership?.userId?.fullName || ownerMembership?.userId?.name || "—",
            lastActivityAt: lastActivity?.lastActiveAt || null,
          };
        })
      );

      return res.status(200).json(enrichedDealers);
    } catch (error) {
      console.error("[Admin Dealers GET]", error);
      return res.status(500).json({ error: "Failed to fetch dealers" });
    }
  }

  // PATCH - Update dealer status, plan, or approval
  if (req.method === "PATCH") {
    try {
      const { dealerId, status, plan, approvalStatus, rejectionReason } = req.body;

      if (!dealerId) {
        return res.status(400).json({ error: "dealerId is required" });
      }

      // Build update object
      const updateData = {};

      // Handle status update
      if (status !== undefined) {
        if (!Object.values(DEALER_STATUS).includes(status)) {
          return res.status(400).json({ error: "Invalid status value" });
        }
        updateData.status = status;
      }

      // Handle plan update
      if (plan !== undefined) {
        if (!Object.values(DEALER_PLAN).includes(plan)) {
          return res.status(400).json({ error: "Invalid plan value" });
        }
        updateData.plan = plan;
      }

      // Handle approval status update
      if (approvalStatus !== undefined) {
        if (!Object.values(APPROVAL_STATUS).includes(approvalStatus)) {
          return res.status(400).json({ error: "Invalid approvalStatus value" });
        }
        updateData.approvalStatus = approvalStatus;

        if (approvalStatus === APPROVAL_STATUS.APPROVED) {
          updateData.approvedAt = new Date();
          updateData.approvedByUserId = ctx.userId;
          updateData.rejectedAt = null;
          updateData.rejectedByUserId = null;
          updateData.rejectionReason = null;
        } else if (approvalStatus === APPROVAL_STATUS.REJECTED) {
          updateData.rejectedAt = new Date();
          updateData.rejectedByUserId = ctx.userId;
          updateData.rejectionReason = rejectionReason || "Application rejected";
          updateData.approvedAt = null;
          updateData.approvedByUserId = null;
        }
      }

      if (Object.keys(updateData).length === 0) {
        return res.status(400).json({ error: "No valid fields to update" });
      }

      const dealer = await Dealer.findByIdAndUpdate(
        dealerId,
        { $set: updateData },
        { new: true }
      ).lean();

      if (!dealer) {
        return res.status(404).json({ error: "Dealer not found" });
      }

      // Log activity based on what was updated
      if (status !== undefined) {
        const activityType = status === DEALER_STATUS.DISABLED
          ? ACTIVITY_TYPES.DEALER_DISABLED
          : ACTIVITY_TYPES.DEALER_ENABLED;

        await PlatformActivity.log(activityType, {
          actorUserId: ctx.userId,
          dealerId: dealer._id,
          metadata: { dealerName: dealer.name },
        });
      }

      if (approvalStatus !== undefined) {
        const activityType = approvalStatus === APPROVAL_STATUS.APPROVED
          ? ACTIVITY_TYPES.DEALER_APPROVED || "DEALER_APPROVED"
          : ACTIVITY_TYPES.DEALER_REJECTED || "DEALER_REJECTED";

        await PlatformActivity.log(activityType, {
          actorUserId: ctx.userId,
          dealerId: dealer._id,
          metadata: { dealerName: dealer.name, approvalStatus, rejectionReason },
        });
      }

      return res.status(200).json({
        id: dealer._id.toString(),
        name: dealer.name,
        status: dealer.status,
        plan: dealer.plan,
        approvalStatus: dealer.approvalStatus,
        approvedAt: dealer.approvedAt,
        rejectedAt: dealer.rejectedAt,
      });
    } catch (error) {
      console.error("[Admin Dealers PATCH]", error);
      return res.status(500).json({ error: "Failed to update dealer" });
    }
  }

  return res.status(405).json({ error: "Method not allowed" });
}

export default withSuperAdmin(handler);
