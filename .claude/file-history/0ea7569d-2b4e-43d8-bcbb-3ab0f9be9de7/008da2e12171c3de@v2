import connectMongo from "@/libs/mongoose";
import Vehicle from "@/models/Vehicle";
import VehicleTask from "@/models/VehicleTask";
import VehicleLabel from "@/models/VehicleLabel";
import VehicleIssue from "@/models/VehicleIssue";
import VehicleLocation from "@/models/VehicleLocation";
import VehicleDocument from "@/models/VehicleDocument";
import VehicleActivity from "@/models/VehicleActivity";
import Deal from "@/models/Deal";
import User from "@/models/User";
import { withDealerContext } from "@/libs/authContext";

const DEFAULT_TASKS = ["PDI", "Valet", "Oil Service Check", "Photos", "Advert"];

// Helper to safely transform MongoDB _id to id
const transformId = (obj) => {
  if (!obj) return null;
  const result = { ...obj };
  if (result._id) {
    result.id = result._id.toString();
    delete result._id;
  }
  delete result.__v;
  return result;
};

async function handler(req, res, ctx) {
  await connectMongo();
  const { dealerId } = ctx;

  if (req.method === "GET") {
    const { status, forSale } = req.query;
    let query = { dealerId };

    // For sale filter: exclude sold vehicles and those already on a deal
    if (forSale === "true") {
      // Exclude sold/delivered/archived vehicles
      query.status = { $nin: ["sold", "delivered", "archived"] };

      // Get vehicle IDs that already have active deals
      const activeDealVehicleIds = await Deal.distinct("vehicleId", {
        dealerId,
        status: { $nin: ["CANCELLED", "COMPLETED"] },
      });

      if (activeDealVehicleIds.length > 0) {
        query._id = { $nin: activeDealVehicleIds };
      }
    } else if (status && status !== "all") {
      query.status = status;
    }

    const vehicles = await Vehicle.find(query)
      .sort({ createdAt: -1 })
      .lean();

    if (!vehicles || vehicles.length === 0) {
      return res.status(200).json([]);
    }

    // Get all vehicle IDs
    const vehicleIds = vehicles.map(v => v._id);

    // Fetch all related data in parallel - scoped by dealerId
    const [allTasks, allIssues, allDocuments, allLocations, allLabels] = await Promise.all([
      VehicleTask.find({ vehicleId: { $in: vehicleIds } }).lean(),
      VehicleIssue.find({ vehicleId: { $in: vehicleIds } }).lean(),
      VehicleDocument.find({ vehicleId: { $in: vehicleIds } }).lean(),
      VehicleLocation.find({ dealerId }).lean(),
      VehicleLabel.find({ dealerId }).lean(),
    ]);

    // Create lookup maps
    const tasksByVehicle = {};
    const issuesByVehicle = {};
    const documentsByVehicle = {};
    const locationsById = {};
    const labelsById = {};

    // Build location lookup
    for (const loc of allLocations) {
      locationsById[loc._id.toString()] = {
        id: loc._id.toString(),
        name: loc.name,
      };
    }

    // Build labels lookup
    for (const label of allLabels) {
      labelsById[label._id.toString()] = {
        id: label._id.toString(),
        name: label.name,
        colour: label.colour,
      };
    }

    // Build tasks lookup
    for (const task of allTasks) {
      const vid = task.vehicleId.toString();
      if (!tasksByVehicle[vid]) tasksByVehicle[vid] = [];
      tasksByVehicle[vid].push(transformId(task));
    }

    // Build issues lookup
    for (const issue of allIssues) {
      const vid = issue.vehicleId.toString();
      if (!issuesByVehicle[vid]) issuesByVehicle[vid] = [];
      issuesByVehicle[vid].push(transformId(issue));
    }

    // Build documents lookup
    for (const doc of allDocuments) {
      const vid = doc.vehicleId.toString();
      if (!documentsByVehicle[vid]) documentsByVehicle[vid] = [];
      documentsByVehicle[vid].push(transformId(doc));
    }

    // Transform vehicles
    const result = vehicles.map(vehicle => {
      const vid = vehicle._id.toString();

      // Get location data
      let locationData = null;
      if (vehicle.locationId) {
        const locId = vehicle.locationId.toString();
        locationData = locationsById[locId] || null;
      }

      return {
        id: vid,
        dealerId: vehicle.dealerId,
        type: vehicle.type,
        saleType: vehicle.saleType,
        regCurrent: vehicle.regCurrent,
        vin: vehicle.vin,
        make: vehicle.make,
        model: vehicle.model,
        derivative: vehicle.derivative,
        year: vehicle.year,
        mileageCurrent: vehicle.mileageCurrent,
        bodyType: vehicle.bodyType,
        fuelType: vehicle.fuelType,
        transmission: vehicle.transmission,
        colour: vehicle.colour,
        status: vehicle.status,
        soldAt: vehicle.soldAt, // For "Sold X days" display
        locationId: locationData,
        motExpiryDate: vehicle.motExpiryDate,
        motStatus: vehicle.motStatus,
        taxExpiryDate: vehicle.taxExpiryDate,
        serviceDueDate: vehicle.serviceDueDate,
        v5Url: vehicle.v5Url,
        serviceHistoryUrl: vehicle.serviceHistoryUrl,
        faultCodesUrl: vehicle.faultCodesUrl,
        websiteUrl: vehicle.websiteUrl,
        notes: vehicle.notes,
        createdAt: vehicle.createdAt,
        updatedAt: vehicle.updatedAt,
        tasks: tasksByVehicle[vid] || [],
        issues: issuesByVehicle[vid] || [],
        documents: documentsByVehicle[vid] || [],
        labels: (vehicle.labels || []).map(labelId => labelsById[labelId.toString()]).filter(Boolean),
      };
    });

    return res.status(200).json(result);
  }

  if (req.method === "POST") {
    const { userId, user } = ctx;
    const {
      regCurrent, vin, make, model, derivative, year,
      mileageCurrent, bodyType, fuelType, transmission, colour,
      status = "in_stock", notes, locationId, skipDefaultTasks,
      type = "STOCK", // STOCK, COURTESY, FLEET_OTHER
      saleType = "RETAIL", // RETAIL, TRADE - only for STOCK vehicles
      motExpiryDate,
      dvlaDetails, // DVLA VES data
      lastDvlaFetchAt,
    } = req.body;

    if (!regCurrent || !make || !model) {
      return res.status(400).json({ error: "Reg, make and model required" });
    }

    const vehicleData = {
      dealerId, // Add dealer context
      regCurrent: regCurrent.toUpperCase().replace(/\s/g, ""),
      vin, make, model, derivative, year,
      mileageCurrent, bodyType, fuelType, transmission, colour,
      status, notes, type,
      createdByUserId: userId,
      // Only set saleType for STOCK vehicles
      ...(type === "STOCK" && { saleType }),
      // MOT expiry from DVSA lookup
      ...(motExpiryDate && { motExpiryDate: new Date(motExpiryDate) }),
      // DVLA VES details
      ...(dvlaDetails && { dvlaDetails }),
      ...(lastDvlaFetchAt && { lastDvlaFetchAt: new Date(lastDvlaFetchAt) }),
    };

    // Only add locationId if it's not empty
    if (locationId) {
      vehicleData.locationId = locationId;
    }

    const vehicle = await Vehicle.create(vehicleData);

    // Create default tasks only if not skipped (for backwards compatibility)
    if (!skipDefaultTasks) {
      for (const taskName of DEFAULT_TASKS) {
        await VehicleTask.create({
          vehicleId: vehicle._id,
          name: taskName,
          status: "pending",
          source: "system_default",
        });
      }
    }

    // Log VEHICLE_CREATED activity
    const actor = await User.findById(userId).lean();
    const actorName = actor?.name || user?.name || user?.email || "System";
    const typeLabel = { STOCK: "Stock", COURTESY: "Courtesy", FLEET_OTHER: "Fleet" }[type] || type;

    await VehicleActivity.log({
      dealerId,
      vehicleId: vehicle._id,
      actorId: userId,
      actorName,
      type: "VEHICLE_CREATED",
      message: `Added ${typeLabel} vehicle: ${make} ${model} (${regCurrent.toUpperCase()})`,
      meta: { type, make, model, regCurrent: regCurrent.toUpperCase() },
    });

    // Transform to include id field
    const vehicleJson = vehicle.toJSON();
    return res.status(201).json(vehicleJson);
  }

  return res.status(405).json({ error: "Method not allowed" });
}

export default withDealerContext(handler);
