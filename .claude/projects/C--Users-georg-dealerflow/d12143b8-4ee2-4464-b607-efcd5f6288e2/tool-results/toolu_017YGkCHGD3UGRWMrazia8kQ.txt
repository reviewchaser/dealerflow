The file C:\Users\georg\dealerflow\pages\sales-prep.js has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
  1241→    }));
  1242→    return allFiltered.length;
  1243→  };
  1244→
  1245→  // VRM Search functions - client-side filtering with unique-by-VRM handling
  1246→  // If vehicles are already loaded, filter client-side for instant results
  1247→  const searchVehiclesClientSide = (query) => {
  1248→    if (query.length < 2 || !vehicles.length) {
  1249→      return [];
  1250→    }
  1251→
  1252→    const normalizedQuery = query.toUpperCase().replace(/\s/g, "");
  1253→
  1254→    // Filter vehicles matching the query (VRM, make, or model)
  1255→    const matches = vehicles.filter((v) => {
  1256→      const vrm = (v.regCurrent || "").toUpperCase().replace(/\s/g, "");
  1257→      const make = (v.make || "").toUpperCase();
  1258→      const model = (v.model || "").toUpperCase();
  1259→      return vrm.includes(normalizedQuery) || make.includes(normalizedQuery) || model.includes(normalizedQuery);
  1260→    });
  1261→
  1262→    // Sort by updatedAt (most recent first)
  1263→    matches.sort((a, b) => {
  1264→      const aDate = new Date(a.updatedAt || a.createdAt || 0);
  1265→      const bDate = new Date(b.updatedAt || b.createdAt || 0);
  1266→      return bDate - aDate;
  1267→    });
  1268→
  1269→    // Group by VRM and keep only the most recent for each VRM
  1270→    const vrmMap = new Map();
  1271→    for (const v of matches) {
  1272→      const vrm = (v.regCurrent || "").toUpperCase();
  1273→      if (!vrmMap.has(vrm)) {
  1274→        vrmMap.set(vrm, v);
  1275→      }
  1276→    }
  1277→
  1278→    // Return unique vehicles (one per VRM, most recent)
  1279→    return Array.from(vrmMap.values()).slice(0, 10);
  1280→  };
  1281→
  1282→  // Fallback API search for when client-side data isn't loaded
  1283→  const searchVehiclesApi = async (query) => {
  1284→    if (query.length < 2) {
  1285→      setVrmSearchResults([]);
  1286→      return;
  1287→    }
  1288→
  1289→    setVrmSearchLoading(true);
  1290→    try {
  1291→      const res = await fetch(`/api/vehicles/search?q=${encodeURIComponent(query)}&limit=20`);
  1292→      if (res.ok) {
  1293→        const results = await res.json();
  1294→        // Sort by updatedAt (most recent activity first)
  1295→        results.sort((a, b) => {
  1296→          const aDate = new Date(a.updatedAt || a.createdAt || 0);
  1297→          const bDate = new Date(b.updatedAt || b.createdAt || 0);
  1298→          return bDate - aDate;
  1299→        });
  1300→
  1301→        // Group by VRM and keep only the most recent for each VRM (for duplicate handling)
  1302→        const vrmMap = new Map();
  1303→        for (const v of results) {
  1304→          const vrm = (v.regCurrent || "").toUpperCase();
  1305→          if (!vrmMap.has(vrm)) {
  1306→            vrmMap.set(vrm, v);
  1307→          }
  1308→        }
  1309→
  1310→        setVrmSearchResults(Array.from(vrmMap.values()).slice(0, 10));
  1311→      }
  1312→    } catch (err) {
  1313→      console.error("VRM search error:", err);
  1314→    } finally {
  1315→      setVrmSearchLoading(false);
  1316→    }
  1317→  };
  1318→
  1319→  const handleVrmSearchChange = (value) => {
  1320→    const normalized = value.toUpperCase();
  1321→    setVrmSearch(normalized);