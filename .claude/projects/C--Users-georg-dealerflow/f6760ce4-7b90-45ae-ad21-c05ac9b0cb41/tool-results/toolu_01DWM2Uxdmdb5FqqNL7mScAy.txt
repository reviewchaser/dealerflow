     1→import { useEffect, useState } from "react";
     2→import Head from "next/head";
     3→import Link from "next/link";
     4→import { useRouter } from "next/router";
     5→import DashboardLayout from "@/components/DashboardLayout";
     6→import ShareFormModal from "@/components/ShareFormModal";
     7→import { BottomSheet } from "@/components/ui/BottomSheet";
     8→import { useSession } from "next-auth/react";
     9→import { toast } from "react-hot-toast";
    10→
    11→// Human-readable form type labels
    12→// Note: Appraisal forms are handled in the dedicated Appraisals section
    13→const FORM_TYPE_LABELS = {
    14→  PDI: "PDI",
    15→  TEST_DRIVE: "Test Drive",
    16→  WARRANTY_CLAIM: "Warranty Claim",
    17→  COURTESY_OUT: "Courtesy Car Out",
    18→  COURTESY_IN: "Courtesy Car In",
    19→  SERVICE_RECEIPT: "Service Receipt",
    20→  REVIEW_FEEDBACK: "Review & Feedback",
    21→  OTHER: "Other",
    22→};
    23→
    24→// Form type colors for icons and accents
    25→const FORM_TYPE_STYLES = {
    26→  PDI: { bg: "bg-blue-50", text: "text-blue-600", accent: "border-blue-500" },
    27→  TEST_DRIVE: { bg: "bg-cyan-50", text: "text-cyan-600", accent: "border-cyan-500" },
    28→  WARRANTY_CLAIM: { bg: "bg-red-50", text: "text-red-600", accent: "border-red-500" },
    29→  COURTESY_OUT: { bg: "bg-emerald-50", text: "text-emerald-600", accent: "border-emerald-500" },
    30→  COURTESY_IN: { bg: "bg-green-50", text: "text-green-600", accent: "border-green-500" },
    31→  SERVICE_RECEIPT: { bg: "bg-teal-50", text: "text-teal-600", accent: "border-teal-500" },
    32→  REVIEW_FEEDBACK: { bg: "bg-pink-50", text: "text-pink-600", accent: "border-pink-500" },
    33→  OTHER: { bg: "bg-slate-50", text: "text-slate-600", accent: "border-slate-500" },
    34→};
    35→
    36→// Small form type icons for list items
    37→const FormTypeIcon = ({ type, size = "w-4 h-4" }) => {
    38→  const iconProps = { className: size, fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 1.5 };
    39→  switch (type) {
    40→    case "PDI":
    41→      return <svg {...iconProps}><path strokeLinecap="round" strokeLinejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>;
    42→    case "TEST_DRIVE":
    43→      return <svg {...iconProps}><path strokeLinecap="round" strokeLinejoin="round" d="M8.25 18.75a1.5 1.5 0 01-3 0m3 0a1.5 1.5 0 00-3 0m3 0h6m-9 0H3.375a1.125 1.125 0 01-1.125-1.125V14.25m17.25 4.5a1.5 1.5 0 01-3 0m3 0a1.5 1.5 0 00-3 0m3 0h1.125c.621 0 1.129-.504 1.09-1.124a17.902 17.902 0 00-3.213-9.193 2.056 2.056 0 00-1.58-.86H14.25M16.5 18.75h-2.25m0-11.177v-.958c0-.568-.422-1.048-.987-1.106a48.554 48.554 0 00-10.026 0 1.106 1.106 0 00-.987 1.106v7.635m12-6.677v6.677m0 4.5v-4.5m0 0h-12" /></svg>;
    44→    case "WARRANTY_CLAIM":
    45→      return <svg {...iconProps}><path strokeLinecap="round" strokeLinejoin="round" d="M9 12.75L11.25 15 15 9.75m-3-7.036A11.959 11.959 0 013.598 6 11.99 11.99 0 003 9.749c0 5.592 3.824 10.29 9 11.623 5.176-1.332 9-6.03 9-11.622 0-1.31-.21-2.571-.598-3.751h-.152c-3.196 0-6.1-1.248-8.25-3.285z" /></svg>;
    46→    case "COURTESY_OUT":
    47→    case "COURTESY_IN":
    48→      return <svg {...iconProps}><path strokeLinecap="round" strokeLinejoin="round" d="M15.75 5.25a3 3 0 013 3m3 0a6 6 0 01-7.029 5.912c-.563-.097-1.159.026-1.563.43L10.5 17.25H8.25v2.25H6v2.25H2.25v-2.818c0-.597.237-1.17.659-1.591l6.499-6.499c.404-.404.527-1 .43-1.563A6 6 0 1121.75 8.25z" /></svg>;
    49→    case "SERVICE_RECEIPT":
    50→      return <svg {...iconProps}><path strokeLinecap="round" strokeLinejoin="round" d="M9 14.25l6-6m4.5-3.493V21.75l-3.75-1.5-3.75 1.5-3.75-1.5-3.75 1.5V4.757c0-1.108.806-2.057 1.907-2.185a48.507 48.507 0 0111.186 0c1.1.128 1.907 1.077 1.907 2.185zM9.75 9h.008v.008H9.75V9zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm4.125 4.5h.008v.008h-.008V13.5zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" /></svg>;
    51→    case "REVIEW_FEEDBACK":
    52→      return <svg {...iconProps}><path strokeLinecap="round" strokeLinejoin="round" d="M11.48 3.499a.562.562 0 011.04 0l2.125 5.111a.563.563 0 00.475.345l5.518.442c.499.04.701.663.321.988l-4.204 3.602a.563.563 0 00-.182.557l1.285 5.385a.562.562 0 01-.84.61l-4.725-2.885a.563.563 0 00-.586 0L6.982 20.54a.562.562 0 01-.84-.61l1.285-5.386a.562.562 0 00-.182-.557l-4.204-3.602a.563.563 0 01.321-.988l5.518-.442a.563.563 0 00.475-.345L11.48 3.5z" /></svg>;
    53→    default:
    54→      return <svg {...iconProps}><path strokeLinecap="round" strokeLinejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" /></svg>;
    55→  }
    56→};
    57→
    58→// Large feature icon for detail panel
    59→const LargeFormIcon = ({ type }) => {
    60→  const styles = FORM_TYPE_STYLES[type] || FORM_TYPE_STYLES.OTHER;
    61→  return (
    62→    <div className={`w-12 h-12 rounded-xl ${styles.bg} ${styles.text} flex items-center justify-center flex-shrink-0`}>
    63→      <FormTypeIcon type={type} size="w-6 h-6" />
    64→    </div>
    65→  );
    66→};
    67→
    68→// Time ago helper
    69→const timeAgo = (date) => {
    70→  const now = new Date();
    71→  const then = new Date(date);
    72→  const seconds = Math.floor((now - then) / 1000);
    73→
    74→  if (seconds < 60) return "Just now";
    75→  if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
    76→  if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
    77→  if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
    78→  return then.toLocaleDateString();
    79→};
    80→
    81→export default function Forms() {
    82→  const router = useRouter();
    83→  const { data: session, status } = useSession();
    84→  const [activeTab, setActiveTab] = useState(router.query.tab || "submissions");
    85→  const [forms, setForms] = useState([]);
    86→  const [filteredForms, setFilteredForms] = useState([]);
    87→  const [submissions, setSubmissions] = useState([]);
    88→  const [filteredSubmissions, setFilteredSubmissions] = useState([]);
    89→  const [isLoading, setIsLoading] = useState(true);
    90→  const [shareForm, setShareForm] = useState(null);
    91→  const [selectedSubmission, setSelectedSubmission] = useState(null);
    92→  const [submissionDetail, setSubmissionDetail] = useState(null);
    93→  const [isLoadingDetail, setIsLoadingDetail] = useState(false);
    94→  const [error, setError] = useState(null);
    95→  const [isEditing, setIsEditing] = useState(false);
    96→  const [editFormData, setEditFormData] = useState({});
    97→  const [isSavingEdit, setIsSavingEdit] = useState(false);
    98→
    99→  // Filters for templates
   100→  const [templateTypeFilter, setTemplateTypeFilter] = useState(router.query.type || "");
   101→
   102→  // Filters for submissions
   103→  const [filterFormType, setFilterFormType] = useState("");
   104→  const [searchQuery, setSearchQuery] = useState("");
   105→  const [vrmSearch, setVrmSearch] = useState("");
   106→  const [selectedFormId, setSelectedFormId] = useState("");
   107→  const [statusFilter, setStatusFilter] = useState("");
   108→  const [showMobileFilters, setShowMobileFilters] = useState(false);
   109→  const [isMobile, setIsMobile] = useState(false);
   110→
   111→  const dealerId = session?.user?.dealerId || "000000000000000000000000";
   112→
   113→  // Detect mobile breakpoint (matches Tailwind's md: breakpoint at 768px)
   114→  useEffect(() => {
   115→    const checkMobile = () => setIsMobile(window.innerWidth < 768);
   116→    checkMobile();
   117→    window.addEventListener("resize", checkMobile);
   118→    return () => window.removeEventListener("resize", checkMobile);
   119→  }, []);
   120→
   121→  // Check if any filters are active
   122→  const hasActiveFilters = vrmSearch || searchQuery || statusFilter || filterFormType || selectedFormId;
   123→  const activeFilterCount = [vrmSearch, searchQuery, statusFilter, filterFormType, selectedFormId].filter(Boolean).length;
   124→
   125→  // Clear all filters
   126→  const clearAllFilters = () => {
   127→    setVrmSearch("");
   128→    setSearchQuery("");
   129→    setStatusFilter("");
   130→    setFilterFormType("");
   131→    setSelectedFormId("");
   132→  };
   133→
   134→  useEffect(() => {
   135→    if (status === "loading") return;
   136→    loadForms();
   137→    loadSubmissions();
   138→  }, [status]);
   139→
   140→  useEffect(() => {
   141→    if (router.query.tab) setActiveTab(router.query.tab);
   142→    if (router.query.type) setTemplateTypeFilter(router.query.type);
   143→  }, [router.query]);
   144→
   145→  useEffect(() => {
   146→    applyFilters();
   147→  }, [submissions, filterFormType, searchQuery, vrmSearch, selectedFormId, statusFilter]);
   148→
   149→  useEffect(() => {
   150→    applyTemplateFilters();
   151→  }, [forms, templateTypeFilter]);
   152→
   153→  // Load submission detail when selected
   154→  useEffect(() => {
   155→    if (selectedSubmission) {
   156→      // Use id or _id depending on what's available (toJSON plugin transforms _id to id)
   157→      const submissionId = selectedSubmission.id || selectedSubmission._id;
   158→      loadSubmissionDetail(submissionId);
   159→    } else {
   160→      setSubmissionDetail(null);
   161→    }
   162→  }, [selectedSubmission]);
   163→
   164→  const loadForms = async () => {
   165→    try {
   166→      setError(null);
   167→      const res = await fetch(`/api/forms?dealerId=${dealerId}`);
   168→      const data = await res.json();
   169→      if (res.ok && Array.isArray(data)) {
   170→        setForms(data);
   171→      } else if (data.error) {
   172→        setError(data.error);
   173→        setForms([]);
   174→      } else {
   175→        setForms([]);
   176→      }
   177→      setIsLoading(false);
   178→    } catch (err) {
   179→      console.error("Failed to load forms:", err);
   180→      setError("Failed to load forms");
   181→      setForms([]);
   182→      setIsLoading(false);
   183→    }
   184→  };
   185→
   186→  const loadSubmissions = async () => {
   187→    try {
   188→      setIsLoading(true);
   189→      const res = await fetch(`/api/forms/submissions?dealerId=${dealerId}`);
   190→      const data = await res.json();
   191→      if (Array.isArray(data)) {
   192→        setSubmissions(data);
   193→        // Auto-select the most recent submission on desktop only (not on mobile)
   194→        // On mobile, we want to show the list first
   195→        const isDesktop = window.innerWidth >= 768;
   196→        if (data.length > 0 && !selectedSubmission && isDesktop) {
   197→          setSelectedSubmission(data[0]);
   198→        }
   199→      } else {
   200→        console.error("API returned non-array:", data);
   201→        setSubmissions([]);
   202→      }
   203→      setIsLoading(false);
   204→    } catch (error) {
   205→      console.error("Failed to load submissions:", error);
   206→      setSubmissions([]);
   207→      setIsLoading(false);
   208→    }
   209→  };
   210→
   211→  const loadSubmissionDetail = async (id) => {
   212→    try {
   213→      setIsLoadingDetail(true);
   214→      console.log("Loading submission detail for ID:", id);
   215→      const res = await fetch(`/api/forms/submissions/${id}`);
   216→      const data = await res.json();
   217→      console.log("API response:", res.status, data);
   218→
   219→      // Check for errors or missing submission
   220→      if (!res.ok || data.error || !data.submission) {
   221→        console.error("Failed to load submission:", data.error || "No submission data", data);
   222→        setSubmissionDetail(null);
   223→        return;
   224→      }
   225→
   226→      setSubmissionDetail(data);
   227→
   228→      // Mark as viewed if it's new
   229→      const submission = submissions.find(s => (s.id || s._id) === id);
   230→      if (submission && !submission.viewed) {
   231→        markAsViewed(id);
   232→      }
   233→    } catch (error) {
   234→      console.error("Failed to load submission detail:", error);
   235→      setSubmissionDetail(null);
   236→    } finally {
   237→      setIsLoadingDetail(false);
   238→    }
   239→  };
   240→
   241→  const markAsViewed = async (id) => {
   242→    try {
   243→      await fetch(`/api/forms/submissions/${id}`, {
   244→        method: "PATCH",
   245→        headers: { "Content-Type": "application/json" },
   246→        body: JSON.stringify({ viewed: true, status: "viewed" }),
   247→      });
   248→      // Update local state
   249→      setSubmissions(prev => prev.map(s =>
   250→        (s.id || s._id) === id ? { ...s, viewed: true, status: "viewed" } : s
   251→      ));
   252→    } catch (error) {
   253→      console.error("Failed to mark as viewed:", error);
   254→    }
   255→  };
   256→
   257→  const applyFilters = () => {
   258→    // Exclude REVIEW_FEEDBACK submissions - they appear in dedicated Reviews page
   259→    let filtered = [...submissions].filter(s => s.formId?.type !== "REVIEW_FEEDBACK");
   260→
   261→    if (filterFormType) {
   262→      filtered = filtered.filter((s) => s.formId?.type === filterFormType);
   263→    }
   264→
   265→    if (selectedFormId) {
   266→      filtered = filtered.filter((s) => s.formId?._id === selectedFormId);
   267→    }
   268→
   269→    if (statusFilter) {
   270→      if (statusFilter === "new") {
   271→        filtered = filtered.filter((s) => !s.viewed && s.status !== "viewed");
   272→      } else {
   273→        filtered = filtered.filter((s) => s.status === statusFilter);
   274→      }
   275→    }
   276→
   277→    if (vrmSearch) {
   278→      const vrmQuery = vrmSearch.toLowerCase().replace(/\s/g, "");
   279→      filtered = filtered.filter((s) => {
   280→        const answers = s.rawAnswers || {};
   281→        const vrmFields = [
   282→          answers.vrm,
   283→          answers.reg,
   284→          answers.registration,
   285→          answers.vehicle_reg,
   286→          answers.regCurrent,
   287→          answers.courtesy_vrm,
   288→        ];
   289→        return vrmFields.some(
   290→          (field) => field && field.toLowerCase().replace(/\s/g, "").includes(vrmQuery)
   291→        );
   292→      });
   293→    }
   294→
   295→    if (searchQuery) {
   296→      const query = searchQuery.toLowerCase();
   297→      filtered = filtered.filter((s) => {
   298→        const answers = s.rawAnswers || {};
   299→        return (
   300→          answers.name?.toLowerCase().includes(query) ||

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
