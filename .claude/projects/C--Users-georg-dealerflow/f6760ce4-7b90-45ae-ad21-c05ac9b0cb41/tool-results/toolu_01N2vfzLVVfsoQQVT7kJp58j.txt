     1→import connectMongo from "@/libs/mongoose";
     2→import HolidayRequest from "@/models/HolidayRequest";
     3→import User from "@/models/User";
     4→import { withDealerContext } from "@/libs/authContext";
     5→
     6→export default withDealerContext(async (req, res, ctx) => {
     7→  await connectMongo();
     8→  const { dealerId, userId, role } = ctx;
     9→
    10→  // GET - List holiday requests
    11→  if (req.method === "GET") {
    12→    try {
    13→      let query = { dealerId };
    14→
    15→      // Staff can only see their own requests; ADMIN/OWNER see all
    16→      if (role === "STAFF" || role === "WORKSHOP") {
    17→        query.userId = userId;
    18→      }
    19→
    20→      // Optional filters
    21→      if (req.query.status) {
    22→        query.status = req.query.status;
    23→      }
    24→      if (req.query.userId && (role === "OWNER" || role === "ADMIN")) {
    25→        query.userId = req.query.userId;
    26→      }
    27→
    28→      const requests = await HolidayRequest.find(query)
    29→        .populate("userId", "name email")
    30→        .sort({ createdAt: -1 })
    31→        .lean();
    32→
    33→      // Enrich with user info and transform _id to id
    34→      const enrichedRequests = requests.map(req => ({
    35→        ...req,
    36→        id: req._id.toString(), // Ensure id is available for frontend
    37→        userName: req.userName || req.userId?.name || req.userId?.email || "Unknown",
    38→        userEmail: req.userEmail || req.userId?.email || "",
    39→        // Compute totalDays if not stored
    40→        totalDays: req.totalDays || (Math.ceil(Math.abs(new Date(req.endDate) - new Date(req.startDate)) / (1000 * 60 * 60 * 24)) + 1),
    41→      }));
    42→
    43→      return res.status(200).json(enrichedRequests);
    44→    } catch (error) {
    45→      console.error("Error fetching holiday requests:", error);
    46→      return res.status(500).json({ error: "Failed to fetch holiday requests" });
    47→    }
    48→  }
    49→
    50→  // POST - Create holiday request
    51→  if (req.method === "POST") {
    52→    try {
    53→      const {
    54→        startDate,
    55→        endDate,
    56→        startSession = "AM",
    57→        endSession = "PM",
    58→        type,
    59→        notes,
    60→        requestForUserId,
    61→      } = req.body;
    62→
    63→      if (!startDate) {
    64→        return res.status(400).json({ error: "Start date is required" });
    65→      }
    66→
    67→      // Validate sessions
    68→      if (!["AM", "PM"].includes(startSession) || !["AM", "PM"].includes(endSession)) {
    69→        return res.status(400).json({ error: "Invalid session values. Must be AM or PM." });
    70→      }
    71→
    72→      // Parse dates
    73→      const start = new Date(startDate);
    74→      // If no end date, default to start date (single day)
    75→      const end = endDate ? new Date(endDate) : new Date(startDate);
    76→
    77→      if (end < start) {
    78→        return res.status(400).json({ error: "End date must be on or after start date" });
    79→      }
    80→
    81→      // Compute total days using the AM/PM logic
    82→      const totalDaysComputed = HolidayRequest.computeTotalDays(start, end, startSession, endSession);
    83→
    84→      if (totalDaysComputed === null) {
    85→        return res.status(400).json({ error: "Invalid date/session combination. PM to AM on the same day is not allowed." });
    86→      }
    87→
    88→      // Prevent absurd date ranges (max 60 days per request)
    89→      if (totalDaysComputed > 60) {
    90→        return res.status(400).json({ error: "Holiday request cannot exceed 60 days. Please submit multiple requests for longer periods." });
    91→      }
    92→
    93→      // Prevent dates too far in the past (max 1 year ago)
    94→      const oneYearAgo = new Date();
    95→      oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
    96→      if (start < oneYearAgo) {
    97→        return res.status(400).json({ error: "Start date cannot be more than 1 year in the past" });
    98→      }
    99→
   100→      // Prevent dates too far in the future (max 2 years ahead)
   101→      const twoYearsFromNow = new Date();
   102→      twoYearsFromNow.setFullYear(twoYearsFromNow.getFullYear() + 2);
   103→      if (end > twoYearsFromNow) {
   104→        return res.status(400).json({ error: "End date cannot be more than 2 years in the future" });
   105→      }
   106→
   107→      // Determine which user the request is for
   108→      let targetUserId = userId;
   109→      let targetUserName = ctx.user.name || ctx.user.email;
   110→      let targetUserEmail = ctx.user.email;
   111→
   112→      // Admin/Owner can create requests for other staff
   113→      if (requestForUserId && (role === "OWNER" || role === "ADMIN")) {
   114→        const targetUser = await User.findById(requestForUserId).lean();
   115→        if (targetUser) {
   116→          targetUserId = requestForUserId;
   117→          targetUserName = targetUser.fullName || targetUser.name || targetUser.email;
   118→          targetUserEmail = targetUser.email;
   119→        }
   120→      } else {
   121→        // Get current user's name
   122→        const currentUser = await User.findById(userId).lean();
   123→        if (currentUser) {
   124→          targetUserName = currentUser.fullName || currentUser.name || currentUser.email;
   125→          targetUserEmail = currentUser.email;
   126→        }
   127→      }
   128→
   129→      const request = await HolidayRequest.create({
   130→        dealerId,
   131→        userId: targetUserId,
   132→        userName: targetUserName,
   133→        userEmail: targetUserEmail,
   134→        startDate: start,
   135→        endDate: end,
   136→        startSession,
   137→        endSession,
   138→        totalDaysComputed,
   139→        totalDays: totalDaysComputed, // legacy field
   140→        type: type || "Holiday",
   141→        notes,
   142→        status: "PENDING",
   143→      });
   144→
   145→      return res.status(201).json(request.toJSON());
   146→    } catch (error) {
   147→      console.error("Error creating holiday request:", error);
   148→      return res.status(500).json({ error: "Failed to create holiday request" });
   149→    }
   150→  }
   151→
   152→  return res.status(405).json({ error: "Method not allowed" });
   153→});
   154→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
