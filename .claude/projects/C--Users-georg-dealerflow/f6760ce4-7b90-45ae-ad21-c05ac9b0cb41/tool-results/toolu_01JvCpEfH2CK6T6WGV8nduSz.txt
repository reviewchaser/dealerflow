     1→import connectMongo from "@/libs/mongoose";
     2→import Appraisal from "@/models/Appraisal";
     3→import CustomerPXAppraisal from "@/models/CustomerPXAppraisal";
     4→import AppraisalIssue from "@/models/AppraisalIssue";
     5→import CustomerPXIssue from "@/models/CustomerPXIssue";
     6→import { withDealerContext } from "@/libs/authContext";
     7→
     8→async function handler(req, res, ctx) {
     9→  if (req.method !== "GET") {
    10→    return res.status(405).json({ error: "Method not allowed" });
    11→  }
    12→
    13→  await connectMongo();
    14→  const { dealerId } = ctx;
    15→
    16→  const { q } = req.query;
    17→
    18→  if (!q || q.length < 2) {
    19→    return res.status(200).json([]);
    20→  }
    21→
    22→  // Normalize search query
    23→  const normalizedQuery = q.toUpperCase().replace(/\s/g, "");
    24→
    25→  // Search both buying appraisals and customer PX appraisals that haven't been converted
    26→  // CRITICAL: Filter by dealerId to prevent cross-tenant data leakage
    27→  const [buyingAppraisals, customerPxAppraisals] = await Promise.all([
    28→    Appraisal.find({
    29→      dealerId, // Tenant scoping
    30→      vehicleReg: { $regex: normalizedQuery, $options: "i" },
    31→      decision: { $in: ["pending", "reviewed"] },
    32→    })
    33→      .sort({ createdAt: -1 })
    34→      .limit(10)
    35→      .lean(),
    36→    CustomerPXAppraisal.find({
    37→      dealerId, // Tenant scoping
    38→      vehicleReg: { $regex: normalizedQuery, $options: "i" },
    39→      decision: { $in: ["pending", "reviewed"] },
    40→    })
    41→      .sort({ createdAt: -1 })
    42→      .limit(10)
    43→      .lean(),
    44→  ]);
    45→
    46→  // Get issues for all appraisals
    47→  const buyingIds = buyingAppraisals.map((a) => a._id);
    48→  const pxIds = customerPxAppraisals.map((a) => a._id);
    49→
    50→  const [buyingIssues, pxIssues] = await Promise.all([
    51→    AppraisalIssue.find({ appraisalId: { $in: buyingIds } }).lean(),
    52→    CustomerPXIssue.find({ customerPXAppraisalId: { $in: pxIds } }).lean(),
    53→  ]);
    54→
    55→  // Create issue count lookups
    56→  const buyingIssueCounts = {};
    57→  for (const issue of buyingIssues) {
    58→    const id = issue.appraisalId.toString();
    59→    buyingIssueCounts[id] = (buyingIssueCounts[id] || 0) + 1;
    60→  }
    61→  const pxIssueCounts = {};
    62→  for (const issue of pxIssues) {
    63→    const id = issue.customerPXAppraisalId.toString();
    64→    pxIssueCounts[id] = (pxIssueCounts[id] || 0) + 1;
    65→  }
    66→
    67→  // Transform and combine results
    68→  const suggestions = [
    69→    ...buyingAppraisals.map((a) => ({
    70→      id: a._id.toString(),
    71→      type: "buying",
    72→      vehicleReg: a.vehicleReg,
    73→      vehicleMake: a.vehicleMake,
    74→      vehicleModel: a.vehicleModel,
    75→      vehicleYear: a.vehicleYear,
    76→      mileage: a.mileage,
    77→      colour: a.colour,
    78→      fuelType: a.fuelType,
    79→      conditionNotes: a.conditionNotes,
    80→      proposedPurchasePrice: a.proposedPurchasePrice,
    81→      serviceHistoryUrl: a.serviceHistoryUrl,
    82→      v5Url: a.v5Url,
    83→      otherDocuments: a.otherDocuments,
    84→      aiHintText: a.aiHintText,
    85→      prepTemplateId: a.prepTemplateId,
    86→      issueCount: buyingIssueCounts[a._id.toString()] || 0,
    87→      decision: a.decision,
    88→      createdAt: a.createdAt,
    89→    })),
    90→    ...customerPxAppraisals.map((a) => ({
    91→      id: a._id.toString(),
    92→      type: "customer_px",
    93→      vehicleReg: a.vehicleReg,
    94→      vehicleMake: a.vehicleMake,
    95→      vehicleModel: a.vehicleModel,
    96→      vehicleYear: a.vehicleYear,
    97→      mileage: a.mileage,
    98→      colour: a.colour,
    99→      fuelType: a.fuelType,
   100→      conditionNotes: a.conditionNotes,
   101→      proposedPurchasePrice: a.proposedPurchasePrice,
   102→      serviceHistoryUrl: a.serviceHistoryUrl,
   103→      v5Url: a.v5Url,
   104→      otherDocuments: a.otherDocuments,
   105→      aiHintText: a.aiHintText,
   106→      prepTemplateId: a.prepTemplateId,
   107→      customerName: a.customerName,
   108→      customerPhone: a.customerPhone,
   109→      customerEmail: a.customerEmail,
   110→      outstandingFinanceAmount: a.outstandingFinanceAmount,
   111→      issueCount: pxIssueCounts[a._id.toString()] || 0,
   112→      decision: a.decision,
   113→      createdAt: a.createdAt,
   114→    })),
   115→  ];
   116→
   117→  // Sort by most recent first
   118→  suggestions.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
   119→
   120→  return res.status(200).json(suggestions.slice(0, 10));
   121→}
   122→
   123→export default withDealerContext(handler);
   124→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
